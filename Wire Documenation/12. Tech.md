Technology
==========

Other chains

Interoperability

-   Projected Consensus via TSS

ECDSA: Elliptic Curve Signatures
--------------------------------

The (Elliptic Curve Digital Signature Algorithm) is a cryptographically secure digital signature scheme, based on elliptic-curve cryptography. ECDSA relies on the math of the cyclic groups of elliptic curves over finite fields and the difficulty of the (elliptic-curve discrete logarithm problem.)

The algorithm relies on EC point multiplication and works as described below. ECDSA keys and signatures are shorter than in RSA for the same security level. A 256-bit ECDSA signature has the same security strength as a 3072-bit RSA signature.

ECDSA uses finite fields in the classical Weierstrass form. These curves are described by their EC domain parameters, specified by various cryptographic standards such as  Elliptic curves, used in cryptography, define:

Generator point G, used for scalar multiplication on the curve (multiply an integer by EC point)

Order n of the subgroup of EC points, generated by G, which defines the length of the private keys (e.g. 256 bits)

For example, the 256-bit elliptic curve secp256k1 has:

Order:

n=115792089237316195423570985008687907852837564279074904382605163141518161494337 (prime number)

Generator point G:

x=55066263022277343669578718895168534326250603453777594175500187360389116729240

y=32670510020758816978083085130507043184471273380659243275938904335757337482424

Key Generation
--------------

The ECDSA key pair consists of:\
The private key (integer): privKey

The public key (EC point): pubKey = privKey * G

The private key is generated as a random integer in the range [0...n-1]. The public key pubKey is a point on the elliptic curve, calculated by the EC point multiplication: pubKey = privKey * G (the private key, multiplied by the generator point G.)

The public key EC point {x, y} can be compressed to just one of the coordinates + 1 bit (parity). For the secp256k1 curve, the private key is a 256-bit integer (32 bytes) and the compressed public key is a 257-bit integer (~ 33 bytes.)

ECDSA Sign
----------

The ECDSA signing algorithm (RFC 6979) takes as input a message msg + a private key privKey and produces as output a signature, which consists of a pair of integers {r, s}

Calculate the message hash, using a cryptographic hash function like SHA-256: h=hash(msg)

Generate securely a random number k in the range [1..n-1]

In the case of deterministic-ECDSA, the value k is HMAC-derived from h + privKey (see)

Calculate the random point R = k * G and take its x-coordinate: r = R.x

Calculate the signature proof: s = k-1∗(h+r∗privKey)(modn)k^{-1} * (h + r * privKey) \pmod nk-1∗(h+r∗privKey)(modn)

​
The modular inverse k-1(modn)k^{-1} \pmod nk-1(modn)

is an integer, such that k∗k-1≡1(modn)k * k^{-1} \equiv 1 \pmod nk∗k-1≡1(modn) ​

Return the signature {r, s}

The calculated signature {r, s} is a pair of integers, each in the range [1...n-1]. It encodes the random point R = k * G, along with a proof s, confirming that the signer knows the message h and the private key privKey. The proof s is by idea verifiable using the corresponding pubKey.

ECDSA signatures are 2 times longer than the signer's private key for the curve used during the signing process. For example, for 256-bit elliptic curves (like secp256k1) the ECDSA signature is 512 bits (64 bytes) and for 521-bit curves (like secp521r1) the signature is 1042 bits.

### ECDSA Verify Signature

The algorithm to verify an ECDSA signature takes as input the signed message msg + the signature {r, s} produced from the signing algorithm + the public key pubKey, corresponding to the signer's private key. The output is a boolean value: valid or invalid signature. The ECDSA signature verifies the algorithm works as follows (with minor simplifications):

Calculate the message hash, with the same cryptographic hash function used during the signing: h = hash(msg)

Calculate the modular inverse of the signature proof: s1 = s-1(modn)s^{-1} \pmod ns-1(modn)

​

Recover the random point used during the signing: R' = (h * s1) * G + (r * s1) * pubKey

Take from R' its x-coordinate: r' = R'.x

Calculate the signature validation result by comparing whether r' == r

The general idea of the signature verification is to recover the point R' using the public key and check whether it is the same point R, generated randomly during the signing process.

### ECDSA: Public Key Recovery from Signature

It is important to know that the ECDSA signature scheme allows the public key to be recovered from the signed message together with the signature. The recovery process is based on some mathematical computations (described in the standard) and returns 0, 1, or 2 possible EC points that are valid public keys, corresponding to the signature. To avoid this ambiguity, some ECDSA implementations add one additional bit v to the signature during the signing process and it takes the form {r, s, v}. From this extended ECDSA signature {r, s, v} + the signed message, the signer's public key can be restored with confidence.

The public key recovery from the ECDSA signature is very useful in bandwidth-constrained or storage-constrained environments (such as blockchain systems) when transmission or storage of the public keys cannot be afforded. For example, the Ethereum blockchain uses extended signatures {r, s, v} for the signed transactions on the chain to save storage and bandwidth.

Public key recovery is possible for signatures, based on the ElGamal signature scheme (such as DSA and ECDSA.)

Authentication
--------------

-   Mixed custody 

-   Proof of Transparency

-   Self Custody

Scalability
-----------

An efficient platform should scale at economically justified thresholds. The platform should scale with no upper limit as long as there is an economic justification for doing so to support enterprise-grade, globally-used applications. AirWire has constructed a design and development model, guided by key principles that reflect the problems inherent in both the centralized and decentralized systems of today.

Network Expansion Events - AirWire uses a sharding approach which allows the network to increase its capacity as additional nodes participate. This is done by dynamically splitting the network nodes into multiple shards when usage is high enough to require it and parallelizing computation across those shards. With this approach, the network can scale continuously as demand increases.

Network Performance - A future-proof protocol must shard both state and processing to scale. With significant adoption of the AirWire platform, no single machine would otherwise be capable of storing all the information on the chain or verifying all of the transactions.

Transaction Priorities and Classification - A lot of recent sharding research in the blockchain community separates transactions into intra-shard and cross-shard categories. Optimizing for the former and providing a much slower solution for the latter. The AirWire Protocol assumes that transactions will touch multiple shards by default, which is the likely behavior for arbitrary smart contracts and optimizes performance accordingly.

System Resources
----------------

-   Inventory (Storage) $INV

-   Power (Compute and Bandwidth) $PWR

-   Chest (Cold Storage) $Chest 

Universal Polymorphic Address Protocol
--------------------------------------

-   Keygen SDK

-   Protocol Standards

-   Name Service

-   Origin . Address . Destination

Pipe Layer Render Engine
------------------------

The Pipe Layer Render Engine consists of putting "after effects" together and Rendering a project. The raw video is then encoded into a workable MP4 file. AirWire has built a version of the pipeline that is for dynamic NFT projects in gaming.    

On-Chain Game State
-------------------