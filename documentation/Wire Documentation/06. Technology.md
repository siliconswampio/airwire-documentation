# Technology

## AirWire Core Technology Includes:

Technology that allows Clients Transmission of tokens on a targeted basis:

AirWire's platform allows anyone to transmit tokens directly and securely through text, email, QR code, social media, or custom links, utilizing our Patent Pending technology.

Reward Earning System (Gig Economy):

AirWire provides features that reward users and influencers with tokens listed on the platform when an activity is completed, such as retweeting a specific message provided by the token. Other earning activities are on the roadmap.

Advanced Advertising Reward Features: 

Advertisers can gain efficiency by offering rewards to users who accept and watch 100% of online videos or messages before the reward can be claimed.

The threshold Signatures Scheme (TSS) removes the burden of the single atomic private key and splits the responsibility between multiple parties. Interoperability is provided within Wire with Projected Consensus via TSS, allowing a multichain game state. With TSS, each party generates its secret and then uses these secrets to distributively sign a transaction without revealing the secrets to the other parties. Using TSS, we remove the burden of having a single atomic private key and split the responsibility between multiple parties.

TSS has two stages:

1. Generating: All the involved parties connect, and each computes their secret; with this share, they distributively compute the public key.
2. Signing: A sub-group of the parties, consisting of at least a threshold plus one party, can distributively sign a transaction without revealing the secrets to the other parties.


## ECDSA: Elliptic Curve Signatures


The (Elliptic Curve Digital Signature Algorithm) is a cryptographically secure digital signature scheme based on Elliptic Curve (EC) cryptography. ECDSA relies on the math of the cyclic groups of Elliptic Curves over finite fields and the difficulty of the (Elliptic Curve discrete logarithm problem.)

The algorithm relies on EC point multiplication and works as described below. ECDSA keys and signatures are shorter than the RSA (Rivest-Shamir-Adleman) cryptosystem for the same security level. A 256-bit ECDSA signature has the same security strength as a 3072-bit RSA signature.

ECDSA uses finite fields in the classical Weierstrass form. These curves, described by their EC domain parameter, are specified by various cryptographic standards such as Elliptic Curves used in cryptography. Define:

Generator point G, used for scalar multiplication on the curve (multiply an integer by EC point)

Order n of the subgroup of EC points generated by G, which defines the length of the private keys (e.g. 256 bits)

For example, the 256-bit Elliptic Curve secp256k1 has:

Order:

n = 115792089237316195423570985008687907852837564279074904382605163141518161494337 (prime number)

Generator point G:

x = 55066263022277343669578718895168534326250603453777594175500187360389116729240

y = 32670510020758816978083085130507043184471273380659243275938904335757337482424

Key Generation
--------------

The ECDSA key pair consists of:

The private key (integer): privKey

The public key (EC point): pubKey = privKey * G

The private key generates as a random integer in the range [0...n-1]. The public key (pubKey) is a point on the elliptic curve, calculated by the EC point multiplication: pubKey = privKey * G (the private key, multiplied by the generator point G.)

The public key EC point {x, y} can compress to just one of the coordinates + 1 bit (parity). For the secp256k1 curve, the private key is a 256-bit integer (32 bytes), and the compressed public key is a 257-bit integer (~ 33 bytes.)

ECDSA Sign
----------

The ECDSA signing algorithm (RFC 6979) takes as input a message msg + a private key privKey and produces as output a signature, which consists of a pair of integers {r, s}

Calculate the message hash, using a cryptographic hash function like SHA-256:
```
h=hash(msg)
```
Generate securely a random number k in the range [1..n-1]

In the case of deterministic-ECDSA, the value k is HMAC-derived from h + privKey (see)

Calculate the random point
```
R = k * G
```
Take its x-coordinate: 
```
r = R.x
```
Calculate the signature proof:
```
s = k - 1 * (h + r * privKey) (modn) k ^ {-1} * (h + r * privKey) \ pmodnk - 1 * (h + r * privKey) (modn)
```
​The modular inverse 
```
k - 1 (modn) k ^ {-1} \ pmod nk - 1 (modn)
```
Is an integer, such that 
```
k * k - 1 ≡ 1 (modn) k * k ^ {-1} \ equiv 1 \ pmod nk * k - 1 ≡ 1 (modn) ​
```
Return the signature
```
{r, s}
```
The calculated signature {r, s} is a pair of integers, each in the range [1...n-1]. It encodes the random point R = k * G, along with proof s, confirming that the signer knows the message h and the private key privKey. The proof s is by idea verifiable using the corresponding pubKey.

ECDSA signatures are two times longer than the signer's private key for the curve used during the signing process. For example, for 256-bit Elliptic Curves (like secp256k1,) the ECDSA signature is 512 bits (64 bytes,) and for 521-bit curves (like secp521r1,) the signature is 1042 bits.

### ECDSA Verify Signature

The algorithm to verify an ECDSA signature takes input as the signed message msg + the signature {r, s} produced from the signing algorithm + the public key pubKey corresponding to the signer's private key. The output is a boolean value: valid or invalid signature. The ECDSA signature verifies the algorithm works as follows (with minor simplifications):

Calculate the message hash with the same cryptographic hash function used during the signing: h = hash(msg)

Calculate the modular inverse of the signature proof:
```
s1 = s - 1 (modn) s ^ {-1} \ pmod ns - 1 (modn)
```

Recover the random point used during the signing: 
```
R' = (h * s1) * G + (r * s1) * pubKey
```

Take from R' its x-coordinate:
```
r' = R'.x
```

Calculate the signature validation result by comparing whether r' == r

The general idea of the signature verification is to recover the point R' using the public key and check whether it is the same point generated randomly during the signing process.

### ECDSA: Public Key Recovery from Signature

It's important to know that the ECDSA signature scheme allows the public key to be recovered from the signed message with the signature together. The recovery process is based on some mathematical computations (described in the standard) and returns 0, 1, or 2 possible EC points that are valid public keys corresponding to the signature. Some ECDSA implementations add one additional bit v to the signature during the signing process to avoid this ambiguity and take the form {r, s, v}. With this extended ECDSA signature {r, s, v} + the signed message, the signer's public key, can be restored with confidence.

The public key recovery from the ECDSA signature is beneficial in bandwidth-constrained or storage-constrained environments (such as blockchain systems) when transmission or storage of the public key, cannot be afforded. For example, the Ethereum blockchain uses extended signatures {r, s, v} for the signed transactions on the chain to save storage and bandwidth.

Public key recovery is possible for signatures based on the ElGamal signature scheme (such as DSA and ECDSA.)

Authentication
--------------

Blockchain Authentication refers to systems that verify users to the resources found in the underlying technology of Bitcoin and other digital currencies. A public blockchain ledger is used to guarantee data validity and security.

All entities interacting with a piece of evidence must provide an irrefutable sign as recognizable proof of their identity. Chain of custody is the process of handling evidence from the time it is collected until it's presented as evidence of authentication. Wire marketplace provides a safe wallet to store and trace your crypto, digital assets and NFTs. Tiers of crypto custody:

* Mixed custody - Forms the forensic link of evidence sequence of control, transfer, and analysis to preserve evidence's integrity and prevents contamination. Can track who has touched and processed the evidence.
* Proof of Transparency - Having the same records spread across large networks for all to see is the core of blockchain transparency.
* Self Custody - Manage your wallet with self-secure cryptocurrencies and build your solution.

Scalability
-----------

An efficient platform should scale at economically justified thresholds. The platform should scale with no upper limit, as long as there is an economic justification in doing so, to support enterprise-grade, globally-used applications. AirWire has constructed a design and development model guided by key principles that reflect the problems inherent in centralized and decentralized systems of today.

Network Expansion Events - AirWire uses a sharding approach which allows the network to increase its capacity as additional nodes participate. It's done by dynamically splitting the network nodes into multiple shards when usage is high enough to require it and parallelizing computation across those shards. With this approach, the network can scale continuously as demand increases.

Network Performance - A future-proof protocol must shard both state and processing to scale. With the significant adoption of the AirWire platform, no single machine would otherwise be capable of storing all the information on the chain or verifying all transactions.

Transaction Priorities and Classification - A lot of recent sharding research in the blockchain community separates transactions into intra-shard and cross-shard categories, becoming optimized for the former and providing a much slower solution for the latter. The AirWire Protocol assumes that transactions will touch multiple shards by default, which is the likely behavior for arbitrary smart contracts, and optimizes performance accordingly.

System Resources
----------------

Wire introduces the concept of resources in the form of $PWR and $INV. $PWR is a regenerative representation of computation and bandwidth, while $INV is a representation of state storage. All Node Operators are provided with a present number of resources tied to their Node Seat Tier. Higher T1 Node Seats get larger allocations of resources than the T2 Node Seats.

Wire provides options of resources that are available for storing your assets such as NFTs, digital art, cryptocurrency and collections on the Wire marketplace. Once you create a profile on Wire you will receive a private and public key. The foundation for Wire is comprised of many resources for users to have options for storing NFTs on Market as inventory (online) or in cold storage offline (Chest.) 

With blockchain authentication, the personal information used to verify someone's identity is on the block's hash, such as name or unique identity number. This decentralized approach will help achieve a self-sovereign digital identity. In such a blockchain authentication system, network users differentiate themselves using a private key.

* Inventory (Storage) $INV - Assets are stored on the marketplace in the form of $INV (online). Storage of inventory is an important part of securing digital assets and cryptocurrency.
* Power (Compute and Bandwidth) $PWR - Regenerative representation of computation and bandwidth, the maximum data transfer rate across a given path.
* Chest (Cold Storage) $Chest - Physical objects in which you would store your cryptocurrencies (ex: Flashdrive or Ledger.) These devices are encrypted with unique security codes to protect your crypto coins while they are accessible anytime.  

Universal Polymorphic Address Protocol
--------------------------------------

Many blockchain networks have developed in recent years. A problem with this is that each chain is isolated, forcing users to silo their liquidity while limiting options to move liquidity and assets between separate ecosystems. 
 
Multiple Blockchains have given developers a variety of platforms on which to run their smart contracts or store their assets based on application features and requirements for throughput, security and cost.  
 
The Universal Polymorphic Address Protocol (UPAP) has provided solutions for this issue. Omnichain, multichain and cross-chain platforms all have aided in transferring property amongst separate blockchains.  
 
UPAP provides a solution with transformational development for the entire blockchain industry. It allows all cryptocurrencies to be convertible onto a single network. 
 
In blockchain gaming, the ability to use individual game assets such as Non-Fungible Tokens (NFTs) in multiple games has the potential to become the new standard. When we talk about blockchain games, their individual NFTs already provide a sense of interoperability. Players who acquire items in one game can sell them on a marketplace to buy new items for a different game.  


Pipe Layer Render Engine
------------------------

The Rendering Pipeline is the sequence of steps it takes when rendering objects. The Pipe Layer Render Engine consists of putting "after effects" together and Rendering a project. 
 
Essentially, a sequence of steps generating the final image on the screen for an NFT. The raw video then gets encoded into a workable MP4 file. Wire has built a version of the pipeline that is for dynamic NFT projects in gaming. 
 
A cross-platform application programming interface (API) for rendering 2D and 3D vector graphics is used in Blockchain cross-platform gaming. Typically, APIs interact with a graphics processing unit (GPU) to achieve hardware-accelerated rendering.
 
A Programmable Graphics Pipeline in Compute Unified Device Architecture (CUDA) is for Order-Independent Transparency. CUDA is a parallel computing platform but also an API. It got designed by a company called NVIDIA specifically to allow software developers to have better control over the physical resources at their disposal. This program transfers data from the first string, to the second string, etc.   